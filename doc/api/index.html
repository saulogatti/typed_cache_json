<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, user-scalable=no">
  <meta name="description" content="typed_cache_json API docs, for the Dart programming language.">
  <title>typed_cache_json - Dart API docs</title>


  
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,300;0,400;0,500;0,700;1,400&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" rel="stylesheet">
  
  <link rel="stylesheet" href="static-assets/github.css?v1">
  <link rel="stylesheet" href="static-assets/styles.css?v1">
  <link rel="icon" href="static-assets/favicon.png?v1">
  
</head>

<body data-base-href="" data-using-base-href="false" class="light-theme">
<div id="overlay-under-drawer"></div>
<header id="title">
  <span id="sidenav-left-toggle" class="material-symbols-outlined" role="button" tabindex="0">menu</span>
  <ol class="breadcrumbs gt-separated dark hidden-xs">
    <li class="self-crumb">typed_cache_json package</li>
  </ol>
  <div class="self-name">typed_cache_json</div>
  <form class="search navbar-right" role="search">
    <input type="text" id="search-box" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
  <button class="toggle" id="theme-button" title="Toggle between light and dark mode" aria-label="Light and dark mode toggle">
    <span id="dark-theme-button" class="material-symbols-outlined" aria-hidden="true">
      dark_mode
    </span>
    <span id="light-theme-button" class="material-symbols-outlined" aria-hidden="true">
      light_mode
    </span>
  </button>
</header>
<main>
  <div id="dartdoc-main-content" class="main-content">
      
<section class="desc markdown">
  <h1 id="typed_cache_json">typed_cache_json</h1>
<p><a href="https://github.com/saulogatti/typed_cache_json"><img src="https://img.shields.io/badge/version-0.1.0-blue.svg" alt="Version"></a></p>
<p>A JSON-based cache backend for the <code>typed_cache</code> package. Provides a simple, type-safe, and persistent solution for storing data in a single JSON file, ideal for Flutter and Dart applications that need lightweight persistence.</p>
<blockquote>
<p><strong>ðŸ“š Complete Documentation:</strong> The entire codebase is fully documented with DartDoc comments. Use your IDE's autocomplete or generate documentation with <code>dart doc</code> to explore the complete API.</p>
</blockquote>
<h2 id="features">Features</h2>
<ul>
<li><strong>Type-Safe Caching:</strong> Store and retrieve objects with type safety using <code>CacheCodec</code>.</li>
<li><strong>JSON Persistence:</strong> All data is saved in a single local JSON file.</li>
<li><strong>Atomic Writes:</strong> Uses temporary (<code>.tmp</code>) and backup (<code>.bak</code>) files to prevent data corruption during writes.</li>
<li><strong>Automatic Recovery:</strong> Attempts to recover data from backups if the main file is corrupted.</li>
<li><strong>Expiration Support (TTL):</strong> Set a time-to-live for your cache entries.</li>
<li><strong>Tag-Based Indexing:</strong> Organize and bulk-remove cache entries using tags.</li>
<li><strong>Flutter Integration:</strong> Easy path resolution (<code>ApplicationSupport</code>, <code>Documents</code>, <code>Temporary</code>) via <code>path_provider</code>.</li>
<li><strong>Thread-Safe:</strong> Operations protected by an async mutex, ensuring safety in concurrent environments.</li>
<li><strong>Complete Documentation:</strong> Fully documented API with examples and detailed explanations.</li>
</ul>
<h2 id="getting-started">Getting Started</h2>
<p>Add the dependency to your <code>pubspec.yaml</code>:</p>
<pre class="language-yaml"><code class="language-yaml">dependencies:
  typed_cache_json:
    git:
      url: https://github.com/saulogatti/typed_cache_json.git
</code></pre>
<h2 id="usage">Usage</h2>
<h3 id="basic-setup-flutter">Basic Setup (Flutter)</h3>
<p>The easiest way to get started with Flutter is using the <code>create</code> function:</p>
<pre class="language-dart"><code class="language-dart">import 'package:typed_cache_json/typed_cache_json.dart';

void main() async {
  // Initialize the cache pointing to the application support directory
  final cache = await create(
    location: CacheLocation.support,
    subdir: 'my_app_cache',
    fileName: 'cache.json',
  );
  
  // Now you can use the cache!
}
</code></pre>
<h4 id="available-locations">Available Locations</h4>
<p>The <code>CacheLocation</code> enum defines where the cache file will be stored:</p>
<ul>
<li><strong><code>CacheLocation.support</code></strong> (Recommended): Internal application files not exposed to the user</li>
<li><strong><code>CacheLocation.temporary</code></strong>: Temporary cache; the OS may clean it when needed</li>
<li><strong><code>CacheLocation.documents</code></strong>: User documents (avoid for cache)</li>
</ul>
<h3 id="advanced-configuration">Advanced Configuration</h3>
<p>If you need more control, you can create the backend directly:</p>
<pre class="language-dart"><code class="language-dart">import 'package:typed_cache_json/typed_cache_json.dart';
import 'package:typed_cache_json/src/json_file_cache_backend.dart';

void main() async {
  // Create the backend with custom settings
  final backend = await JsonFileCacheBackend.fromLocation(
    location: CacheLocation.support,
    subdir: 'my_app_cache',
    fileName: 'cache.json',
    enableRecovery: true, // Enable automatic recovery (default: true)
  );

  // Create the cache with the backend
  final cache = createTypedCache(
    backend: backend,
    deleteCorruptedEntries: true, // Automatically remove corrupted entries
  );
}
</code></pre>
<h3 id="storing-and-retrieving-data">Storing and Retrieving Data</h3>
<p>To use the cache, you need to define a <code>CacheCodec</code> for your data type:</p>
<pre class="language-dart"><code class="language-dart">import 'package:typed_cache/typed_cache.dart';

class User {
  final String name;
  final int age;
  User(this.name, this.age);
}

class UserCodec extends CacheCodec&lt;User, Map&lt;String, dynamic&gt;&gt; {
  @override
  String get typeId =&gt; 'user';

  @override
  User decode(Map&lt;String, dynamic&gt; data) {
    return User(data['name'] as String, data['age'] as int);
  }

  @override
  Map&lt;String, dynamic&gt; encode(User value) {
    return {'name': value.name, 'age': value.age};
  }
}

// Using the cache
void main() async {
  final cache = await create(
    location: CacheLocation.support,
    fileName: 'cache.json',
  );
  
  final user = User('Saulo', 30);
  final codec = UserCodec();

  // Save
  await cache.put('user_1', user, codec: codec);

  // Retrieve
  final cachedUser = await cache.get('user_1', codec: codec);
  print('Name: ${cachedUser?.name}, Age: ${cachedUser?.age}');
}
</code></pre>
<h3 id="using-the-built-in-json-codec">Using the Built-in JSON Codec</h3>
<p>For simple data in Map format, you can use the included <code>CacheJsonCodec</code>:</p>
<pre class="language-dart"><code class="language-dart">import 'package:typed_cache_json/typed_cache_json.dart';

void main() async {
  final cache = await create(
    location: CacheLocation.support,
    fileName: 'cache.json',
  );
  
  final codec = CacheJsonCodec();
  
  // Save a Map directly
  await cache.put('config', {'theme': 'dark', 'version': 2}, codec: codec);
  
  // Retrieve
  final config = await cache.get('config', codec: codec);
  print('Theme: ${config?['theme']}');
}
</code></pre>
<h3 id="using-tags-and-ttl">Using Tags and TTL</h3>
<pre class="language-dart"><code class="language-dart">// Save with 1-hour expiration and tags
await cache.put(
  'session_data', 
  sessionData, 
  codec: myCodec,
  ttl: Duration(hours: 1),
  tags: {'session', 'auth'},
);

// Invalidate everything with the 'session' tag
await cache.invalidateByTag('session');

// Get all keys with a specific tag
final sessionKeys = await cache.keysByTag('session');
print('Session keys: $sessionKeys');
</code></pre>
<h3 id="cleaning-expired-cache">Cleaning Expired Cache</h3>
<p>The cache does not automatically remove expired entries from disk (except when you try to read an expired key). To clean the file:</p>
<pre class="language-dart"><code class="language-dart">// Remove all expired entries from the JSON file
final count = await cache.purgeExpired();
print('$count entries removed');
</code></pre>
<h3 id="complete-cache-clear">Complete Cache Clear</h3>
<p>To remove all cache data:</p>
<pre class="language-dart"><code class="language-dart">// Clear all cache
await cache.clear();
</code></pre>
<h2 id="file-structure">File Structure</h2>
<p>The backend maintains a JSON file with the following structure:</p>
<pre class="language-json"><code class="language-json">{
  "schemaVersion": 1,
  "entries": {
    "key1": {
      "key": "key1",
      "typeId": "user",
      "payload": { "name": "Saulo", "age": 30 },
      "createdAt": 1700000000000,
      "expiresAt": 1700003600000,
      "tags": ["session"]
    }
  },
  "tagIndex": {
    "session": ["key1"]
  }
}
</code></pre>
<h3 id="safety-files">Safety Files</h3>
<p>During write operations, the backend creates auxiliary files:</p>
<ul>
<li><strong><code>cache.json.tmp</code></strong>: Temporary file used during write operations</li>
<li><strong><code>cache.json.bak</code></strong>: Backup of the previous file, used for recovery in case of corruption</li>
</ul>
<p>These files are managed automatically and ensure data integrity.</p>
<h2 id="data-recovery">Data Recovery</h2>
<p>The package includes a robust data recovery system:</p>
<ol>
<li>If the main file is corrupted, it attempts to load from <code>.bak</code></li>
<li>If the <code>.bak</code> is also corrupted, it tries the <code>.tmp</code> file</li>
<li>If none work, it initializes an empty cache</li>
</ol>
<p>You can disable automatic recovery when creating the backend:</p>
<pre class="language-dart"><code class="language-dart">final backend = await JsonFileCacheBackend.fromLocation(
  location: CacheLocation.support,
  fileName: 'cache.json',
  enableRecovery: false, // Disable recovery
);
</code></pre>
<h2 id="logging">Logging</h2>
<p>For debugging and monitoring, you can enable logs when creating the cache:</p>
<pre class="language-dart"><code class="language-dart">final cache = await create(
  location: CacheLocation.support,
  fileName: 'cache.json',
  logger: (message) =&gt; print('[Cache] $message'),
);
</code></pre>
<h2 id="architecture-and-internal-workings">Architecture and Internal Workings</h2>
<h3 id="main-components">Main Components</h3>
<p>The package is organized into specialized components:</p>
<h4 id="1-jsonfilecachebackend">1. <strong>JsonFileCacheBackend</strong></h4>
<p>Main backend that implements <code>CacheBackend</code> from <code>typed_cache</code>. Responsible for:</p>
<ul>
<li>Atomic read/write operations</li>
<li>Entry lifecycle management</li>
<li>Tag index maintenance</li>
<li>Automatic failure recovery</li>
</ul>
<h4 id="2-asyncmutex">2. <strong>AsyncMutex</strong></h4>
<p>Async mutex that serializes concurrent operations. Ensures that:</p>
<ul>
<li>I/O operations don't overlap</li>
<li>Internal state remains consistent</li>
<li>Errors in one operation don't block others</li>
</ul>
<h4 id="3-jsoncachefile">3. <strong>JsonCacheFile</strong></h4>
<p>Data model that represents the JSON file structure in memory:</p>
<ul>
<li>Stores all cache entries</li>
<li>Maintains reverse tag index for efficient searches</li>
<li>Serializes/deserializes the JSON file</li>
</ul>
<h4 id="4-cachejsoncodec">4. <strong>CacheJsonCodec</strong></h4>
<p>Pre-built codec for simple JSON data (<code>Map&lt;String, dynamic&gt;</code>):</p>
<ul>
<li>Facilitates storage of configurations and structured data</li>
<li>No need to create custom codecs for simple data</li>
</ul>
<h3 id="operation-flow">Operation Flow</h3>
<h4 id="write-operation">Write Operation</h4>
<pre class="language-dart"><code>TypedCache.put() 
  â†’ JsonFileCacheBackend.write()
  â†’ _mutex.synchronized()
    â†’ _load() (load file)
    â†’ _upsertEntry() (update entry and tag index)
    â†’ _save()
      â†’ _atomicWrite() (write .tmp â†’ rename â†’ backup .bak)
</code></pre>
<h4 id="read-operation">Read Operation</h4>
<pre class="language-dart"><code>TypedCache.get()
  â†’ JsonFileCacheBackend.read()
  â†’ _mutex.synchronized()
    â†’ _load() (load and cache in memory during operation)
    â†’ return entry or null
</code></pre>
<h4 id="failure-recovery">Failure Recovery</h4>
<pre class="language-dart"><code>_load() fails
  â†’ _recoverOrEmpty() (if enableRecovery = true)
    â†’ try .bak
    â†’ try .tmp
    â†’ return empty if all fail
</code></pre>
<h3 id="thread-safety-guarantees">Thread-Safety Guarantees</h3>
<p>All public operations are protected by <code>AsyncMutex</code>, ensuring:</p>
<ul>
<li><strong>Serialization:</strong> Operations execute one at a time, in submission order</li>
<li><strong>Consistency:</strong> File and index state always synchronized</li>
<li><strong>Isolation:</strong> Errors in one operation don't affect others</li>
</ul>
<h3 id="durability-guarantees">Durability Guarantees</h3>
<p>The atomic write protocol ensures:</p>
<ul>
<li><strong>Atomicity:</strong> Complete write or no write (no partial corruption)</li>
<li><strong>Automatic Backup:</strong> Previous version always preserved in <code>.bak</code></li>
<li><strong>Recovery:</strong> System tries multiple paths before giving up</li>
</ul>
<h2 id="additional-information">Additional Information</h2>
<h3 id="compatibility">Compatibility</h3>
<ul>
<li><strong>Dart SDK</strong>: ^3.10.4</li>
<li><strong>Flutter</strong>: Compatible</li>
<li><strong>Platforms</strong>: iOS, Android, macOS, Windows, Linux</li>
</ul>
<h3 id="api-documentation">API Documentation</h3>
<p>All code in this package is fully documented with DartDoc comments. The documentation includes:</p>
<ul>
<li><strong>Detailed Descriptions:</strong> Each class, method, and property has a clear description</li>
<li><strong>Usage Examples:</strong> Practical examples for main features</li>
<li><strong>Parameters and Returns:</strong> Complete documentation of all parameters and return values</li>
<li><strong>Exceptions:</strong> Information about possible errors and how to handle them</li>
<li><strong>Implementation Notes:</strong> Details about internal behavior and thread-safety guarantees</li>
</ul>
<h4 id="how-to-access-documentation">How to Access Documentation</h4>
<ol>
<li><strong>Via IDE:</strong> Use autocomplete (Ctrl+Space / Cmd+Space) and hover over any symbol to see inline documentation</li>
<li><strong>Generate HTML:</strong> Run <code>dart doc</code> in the project directory to generate navigable HTML documentation</li>
<li><strong>Read the Code:</strong> DartDoc comments are visible directly in source files</li>
</ol>
<h4 id="main-documented-classes">Main Documented Classes</h4>
<ul>
<li><strong><code>JsonFileCacheBackend</code>:</strong> Main backend with atomic operations and automatic recovery</li>
<li><strong><code>AsyncMutex</code>:</strong> Async mutex implementation for operation serialization</li>
<li><strong><code>CacheJsonCodec</code>:</strong> Pre-built codec for simple JSON data</li>
<li><strong><code>JsonCacheFile</code>:</strong> Internal cache file model</li>
<li><strong><code>CacheLocation</code>:</strong> Enum for choosing cache file location</li>
</ul>
<h3 id="useful-links">Useful Links</h3>
<ul>
<li><a href="https://github.com/saulogatti/typed_cache">typed_cache</a> - Base caching package</li>
<li><a href="https://github.com/saulogatti/typed_cache_json">Repository</a></li>
</ul>
<h3 id="advanced-resources">Advanced Resources</h3>
<p>For more details about:</p>
<ul>
<li>Creating complex codecs</li>
<li>Custom TTL policies</li>
<li>Invalidation strategies</li>
<li>Performance optimizations</li>
</ul>
<p>See the <a href="https://github.com/saulogatti/typed_cache">typed_cache documentation</a>.</p>
<h2 id="best-practices">Best Practices</h2>
<h3 id="choosing-storage-location">Choosing Storage Location</h3>
<ul>
<li><strong>Use <code>CacheLocation.support</code></strong> for most cases - it's the recommended location for cache</li>
<li><strong>Use <code>CacheLocation.temporary</code></strong> only for truly disposable cache that can be cleared by the OS</li>
<li><strong>Avoid <code>CacheLocation.documents</code></strong> for cache - it's for user-visible files</li>
</ul>
<h3 id="tag-management">Tag Management</h3>
<pre class="language-dart"><code class="language-dart">// Organize related entries with tags
await cache.put('user_123', userData, codec: codec, tags: {'user', 'session'});
await cache.put('config_123', configData, codec: codec, tags: {'config', 'session'});

// Clear everything related to session at once
await cache.invalidateByTag('session');
</code></pre>
<h3 id="periodic-cleanup">Periodic Cleanup</h3>
<pre class="language-dart"><code class="language-dart">// Run periodically to keep the file optimized
Future&lt;void&gt; performCacheMaintenance() async {
  final removed = await cache.purgeExpired();
  print('Removed $removed expired entries');
}

// Example: run on app startup
void main() async {
  final cache = await create(/*...*/);
  await performCacheMaintenance();
  runApp(MyApp());
}
</code></pre>
<h3 id="custom-codecs">Custom Codecs</h3>
<pre class="language-dart"><code class="language-dart">// For complex objects, create specific codecs
class UserCodec extends CacheCodec&lt;User, Map&lt;String, dynamic&gt;&gt; {
  @override
  String get typeId =&gt; 'user:v1'; // Include version in typeId
  
  @override
  User decode(Map&lt;String, dynamic&gt; data) {
    return User.fromJson(data);
  }
  
  @override
  Map&lt;String, dynamic&gt; encode(User value) {
    return value.toJson();
  }
}
</code></pre>
<h3 id="error-handling">Error Handling</h3>
<pre class="language-dart"><code class="language-dart">try {
  final data = await cache.get('key', codec: codec);
  if (data == null) {
    // Key doesn't exist or has expired
    print('Cache miss');
  }
} catch (e) {
  // I/O error or corruption
  print('Error accessing cache: $e');
  // The cache attempts automatic recovery
}
</code></pre>
<h2 id="troubleshooting">Troubleshooting</h2>
<h3 id="cache-doesnt-persist-between-runs">Cache doesn't persist between runs</h3>
<p><strong>Cause:</strong> Possible use of <code>CacheLocation.temporary</code> on device with low space.
<strong>Solution:</strong> Use <code>CacheLocation.support</code> for data that should persist.</p>
<h3 id="file-gets-corrupted-repeatedly">File gets corrupted repeatedly</h3>
<p><strong>Cause:</strong> Possible write failure (e.g., app terminated abruptly).
<strong>Solution:</strong> The automatic recovery system should resolve it. If it persists:</p>
<pre class="language-dart"><code class="language-dart">// Force a complete cleanup
await cache.clear();
</code></pre>
<h3 id="slow-performance-with-many-entries">Slow performance with many entries</h3>
<p><strong>Cause:</strong> Large JSON file being loaded/saved on every operation.
<strong>Solutions:</strong></p>
<ul>
<li>Run <code>purgeExpired()</code> periodically</li>
<li>Use TTL to limit entry lifespan</li>
<li>Consider splitting into multiple cache files by context</li>
<li>Use tags to organize and clean groups of entries</li>
</ul>
<h3 id="permission-denied-error">"Permission Denied" error</h3>
<p><strong>Cause:</strong> Attempting to access directory without appropriate permissions.
<strong>Solution:</strong> Use <code>CacheLocation.support</code> which always has proper permissions.</p>
<h3 id="data-disappears-on-ios">Data disappears on iOS</h3>
<p><strong>Cause:</strong> Use of <code>CacheLocation.temporary</code> - iOS aggressively clears this folder.
<strong>Solution:</strong> Use <code>CacheLocation.support</code> for data that should persist.</p>
<h2 id="contributing">Contributing</h2>
<p>Contributions are welcome! Feel free to open issues or pull requests.</p>
<h2 id="license">License</h2>
<p>This project is open source. Check the LICENSE file for more details.</p>
</section>


      <section class="summary">
          <h2>Libraries</h2>
        <dl>
          <dt id="typed_cache_json">
  <span class="name"><a href="typed_cache_json/">typed_cache_json</a></span> 

</dt>
<dd>A JSON-based backend implementation for the <code>typed_cache</code> package.
</dd>

        </dl>
      </section>
  </div> <!-- /.main-content -->
  <div id="dartdoc-sidebar-left" class="sidebar sidebar-offcanvas-left">
    <!-- The search input and breadcrumbs below are only responsively visible at low resolutions. -->
<header id="header-search-sidebar" class="hidden-l">
  <form class="search-sidebar" role="search">
    <input type="text" id="search-sidebar" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
</header>
<ol class="breadcrumbs gt-separated dark hidden-l" id="sidebar-nav">
    <li class="self-crumb">typed_cache_json package</li>
</ol>

    <h5 class="hidden-xs"><span class="package-name">typed_cache_json</span> <span class="package-kind">package</span></h5>
    <ol>
      <li class="section-title">Libraries</li>
      <li><a href="typed_cache_json/">typed_cache_json</a></li>
</ol>

  </div>
  <div id="dartdoc-sidebar-right" class="sidebar sidebar-offcanvas-right">
  </div>
</main>
<footer>
  <span class="no-break">
    typed_cache_json
      0.2.0
  </span>
  
</footer>


<script src="static-assets/highlight.pack.js?v1"></script>
<script src="static-assets/docs.dart.js"></script>

</body>
</html>

